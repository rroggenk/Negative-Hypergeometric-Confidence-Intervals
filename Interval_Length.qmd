---
title: "Interval Length"
author: "Rachel Roggenkemper"
format: html
editor: visual
---

```{r}
library(extraDistr)
library(tidyverse)

source('functions.R', encoding = 'UTF-8')
```

# Expected Length

```{r}
expected_length <- function(data_frame, lb_col_name, ub_col_name, N, M, m) {
  sum = 0
  for (xi in 0:(N - M)) {
    length = data_frame[[ub_col_name]][data_frame$x == xi] -
      data_frame[[lb_col_name]][data_frame$x == xi] + 1
    prob = ngh_pmf(x = xi, N = N, M = M, m = m)
    indiv = length * prob
    sum = sum + indiv
  }
  return(sum)
}
```

# Average Length

```{r}
average_length <- function(data_frame, lb_col_name, ub_col_name) {
  length = data_frame[[ub_col_name]] - data_frame[[lb_col_name]] + 1
  average_length = mean(length)
  return(average_length)
}
```

# Note: Minimal Cardinality Procedures

The average length is the same for the minimal cardinality procedures. This is because they are choosing choosing between acceptance sets of minimal cardinality (so the same minimal length). The only difference is between which minimal cardinality sets are being chosen, but the length of them is the same since they are minimal cardinality. Thus, the average length is the same for the minimal cardinality procedures.

Therefore, Modified Sterne (MST) is considered superior because they all have the same average length, but MST chooses the acceptance sets with the highest coverage probability, so with the same length as the other minimal cardinality procedures, MST is getting the most coverage.

# Plot of Expected and Average Length

## First choose N, m, and confidence level!

```{r}
N = 50
m = 3
conf_level = 0.95
```

## Normal Approximation (MLE)

```{r}
data = CI_cov_prob_MLE(N = N, m = m, conf_level = conf_level)
average_length(data, "lower_bound", "upper_bound")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "lower_bound", "upper_bound", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "lower_bound", "upper_bound"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## Normal Approximation (Unbiased)

```{r}
data = CI_cov_prob_unbiased(N = N, m = m, conf_level = conf_level)
average_length(data, "lower_bound", "upper_bound")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "lower_bound", "upper_bound", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "lower_bound", "upper_bound"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## Analog to Clopper-Pearson

```{r}
data = CI_cov_prob(N = N, m = m, conf_level = conf_level)
average_length(data, "lower_bound", "upper_bound")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "lower_bound", "upper_bound", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "lower_bound", "upper_bound"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## MST

```{r}
data = minimal_cardinality_ci(N = N, m = m, conf_level = conf_level, procedure = "MST")
average_length(data, "ci_lb", "ci_ub")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "ci_lb", "ci_ub", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "ci_lb", "ci_ub"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## CG

```{r}
data = minimal_cardinality_ci(N = N, m = m, conf_level = conf_level, procedure = "CG")
average_length(data, "ci_lb", "ci_ub")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "ci_lb", "ci_ub", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "ci_lb", "ci_ub"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## BK

```{r}
data = minimal_cardinality_ci(N = N, m = m, conf_level = conf_level, procedure = "BK")
average_length(data, "ci_lb", "ci_ub")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "ci_lb", "ci_ub", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "ci_lb", "ci_ub"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## Blaker

```{r}
data = blaker_ci(N = N, m = m, conf_level = conf_level)
average_length(data, "ci_lb", "ci_ub")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "ci_lb", "ci_ub", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "ci_lb", "ci_ub"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

## CMC

```{r}
data = cmc_ci(N = N, m = m, conf_level = conf_level)
average_length(data, "ci_lb", "ci_ub")



# Create a data frame to store the results
results = data.frame(M = integer(), ExpectedLength = numeric())

# Calculate expected length for each M
for (M_i in m:N) {
  exp_len = expected_length(data, "ci_lb", "ci_ub", N = N, M = M_i, m = m)
  results = rbind(results, data.frame(M = M_i, ExpectedLength = exp_len))
}

# Plot using ggplot2
ggplot(results, aes(x = M, y = ExpectedLength)) +
  geom_point() +
  geom_hline(yintercept = average_length(data, "ci_lb", "ci_ub"), color = "red") +
  labs(x = "M", y = "Expected Length") +
  theme_minimal()
```

# Plot of Expected Length

## Data Preparation

```{r}
# Initialize the variables
conf_level <- 0.95
Ns <- c(50, 200)
ms <- c(3, 20)

# Initialize an empty data frame to store all the results
all_results <- data.frame()

# Loop through each combination of N and m
for (N in Ns) {
  for (m in ms) {
    
    methods <- list(
      "Normal Approximation (MLE)" = CI_cov_prob_MLE(N = N, m = m, conf_level = conf_level),
      "Normal Approximation (Unbiased)" = CI_cov_prob_unbiased(N = N, m = m, conf_level = conf_level),
      "Analog to Clopper-Pearson" = CI_cov_prob(N = N, m = m, conf_level = conf_level),
      "MST" = minimal_cardinality_ci(N = N, m = m, conf_level = conf_level, procedure = "MST"),
      "CG" = minimal_cardinality_ci(N = N, m = m, conf_level = conf_level, procedure = "CG"),
      "BK" = minimal_cardinality_ci(N = N, m = m, conf_level = conf_level, procedure = "BK"),
      "Blaker" = blaker_ci(N = N, m = m, conf_level = conf_level),
      "CMC" = cmc_ci(N = N, m = m, conf_level = conf_level)
    )
    
    for (method_name in names(methods)) {
      data <- methods[[method_name]]
      
      # Determine the correct column names for bounds
      if (method_name %in% c("Normal Approximation (MLE)", "Normal Approximation (Unbiased)", "Analog to Clopper-Pearson")) {
        lb_col <- "lower_bound"
        ub_col <- "upper_bound"
      } else {
        lb_col <- "ci_lb"
        ub_col <- "ci_ub"
      }
      
      # Check if the method returned valid data
      if (nrow(data) > 0) {
        
        # Calculate expected length for each M
        results <- data.frame(M = integer(), ExpectedLength = numeric(), Method = character(), N = integer(), m = integer())
        
        for (M_i in m:N) {
          exp_len <- expected_length(data, lb_col, ub_col, N = N, M = M_i, m = m)
          
          # Only add to results if exp_len is not empty or NULL
          if (!is.null(exp_len) && length(exp_len) > 0) {
            results <- rbind(results, data.frame(M = M_i, ExpectedLength = exp_len, Method = method_name, N = N, m = m))
          }
        }
        
        all_results <- rbind(all_results, results)
      }
    }
  }
}
```

```{r}
# Saved as CSV file b/c takes a while to run 
# write.csv(all_results, file.path(getwd(), "expected_length.csv"), row.names = FALSE)
```

## Plot

```{r}
all_results = read_csv("expected_length.csv")

ggplot(all_results, aes(x = M, y = ExpectedLength, color = Method)) +
  geom_line() +
  facet_grid(m ~ N, scales = "free") +  # Create the 2x2 plot with facets
  labs(x = "M", y = "Expected Length", color = "Method") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

# Plot of Average Length

```{r}

```
