---
title: "Minimal Cardinality Procedures (N Unkown)"
author: "Rachel Roggenkemper"
format: html
editor: visual
---

## Loading in Packages and Functions

```{r}
library(extraDistr)
library(tidyverse)

source('../functions.R', encoding = 'UTF-8')
```

# Minimal Cardinality Acceptance Curves

## Manually Testing: M = 10, m = 5, CL = 0.95

### N = 10

-\> 0-0 with CP = 1

```{r}
sum_ngh_pmf(N = 10, M = 10, m = 5, min_x = 0, max_x = 0)
sum_ngh_pmf(N = 10, M = 10, m = 5, min_x = 1, max_x = 1)

sum_ngh_pmf(N = 10, M = 10, m = 5, min_x = 0, max_x = 1)
```

### N = 11

-\> 0-1 with CP = 1

```{r}
sum_ngh_pmf(N = 11, M = 10, m = 5, min_x = 0, max_x = 0)
sum_ngh_pmf(N = 11, M = 10, m = 5, min_x = 1, max_x = 1)

sum_ngh_pmf(N = 11, M = 10, m = 5, min_x = 0, max_x = 1)
```

### N = 12

-\> 0-2 with CP = 1

```{r}
sum_ngh_pmf(N = 12, M = 10, m = 5, min_x = 0, max_x = 1)
sum_ngh_pmf(N = 12, M = 10, m = 5, min_x = 1, max_x = 2)

sum_ngh_pmf(N = 12, M = 10, m = 5, min_x = 0, max_x = 2)
sum_ngh_pmf(N = 12, M = 10, m = 5, min_x = 1, max_x = 3)
```

### N = 13

-\> 0-3 with CP = 1

```{r}
sum_ngh_pmf(N = 13, M = 10, m = 5, min_x = 0, max_x = 2)
sum_ngh_pmf(N = 13, M = 10, m = 5, min_x = 1, max_x = 3)

sum_ngh_pmf(N = 13, M = 10, m = 5, min_x = 0, max_x = 3)
sum_ngh_pmf(N = 13, M = 10, m = 5, min_x = 1, max_x = 4)
```

### N = 14

-\> 0-4 with CP = 1

```{r}
sum_ngh_pmf(N = 14, M = 10, m = 5, min_x = 0, max_x = 3)
sum_ngh_pmf(N = 14, M = 10, m = 5, min_x = 1, max_x = 4)

sum_ngh_pmf(N = 14, M = 10, m = 5, min_x = 0, max_x = 4)
sum_ngh_pmf(N = 14, M = 10, m = 5, min_x = 1, max_x = 5)
```

### N = 15

-\> 0-4 with CP = 0.958042

```{r}
sum_ngh_pmf(N = 15, M = 10, m = 5, min_x = 0, max_x = 4)
sum_ngh_pmf(N = 15, M = 10, m = 5, min_x = 1, max_x = 5)
```

### N = 16

-\> 0-5 with CP = 0.9737762

```{r}
sum_ngh_pmf(N = 16, M = 10, m = 5, min_x = 0, max_x = 4)
sum_ngh_pmf(N = 16, M = 10, m = 5, min_x = 1, max_x = 5)
sum_ngh_pmf(N = 16, M = 10, m = 5, min_x = 2, max_x = 6)

sum_ngh_pmf(N = 16, M = 10, m = 5, min_x = 0, max_x = 5)
sum_ngh_pmf(N = 16, M = 10, m = 5, min_x = 1, max_x = 6)
sum_ngh_pmf(N = 16, M = 10, m = 5, min_x = 2, max_x = 7)
```

### N = 17

-\> 0-6 with CP = 0.9830317

-\> 1-7 with CP = 0.959276

```{r}
sum_ngh_pmf(N = 17, M = 10, m = 5, min_x = 0, max_x = 5)
sum_ngh_pmf(N = 17, M = 10, m = 5, min_x = 1, max_x = 6)
sum_ngh_pmf(N = 17, M = 10, m = 5, min_x = 2, max_x = 7)

sum_ngh_pmf(N = 17, M = 10, m = 5, min_x = 0, max_x = 6)
sum_ngh_pmf(N = 17, M = 10, m = 5, min_x = 1, max_x = 7)
sum_ngh_pmf(N = 17, M = 10, m = 5, min_x = 2, max_x = 8)
```

### N = 18

-\> 1-7 with CP = 0.959276

```{r}
sum_ngh_pmf(N = 18, M = 10, m = 5, min_x = 1, max_x = 7)
sum_ngh_pmf(N = 18, M = 10, m = 5, min_x = 2, max_x = 8)
```

### N = 19

-\> 1-8 with CP = 0.9705882

```{r}
sum_ngh_pmf(N = 19, M = 10, m = 5, min_x = 1, max_x = 7)
sum_ngh_pmf(N = 19, M = 10, m = 5, min_x = 2, max_x = 8)

sum_ngh_pmf(N = 19, M = 10, m = 5, min_x = 1, max_x = 8)
sum_ngh_pmf(N = 19, M = 10, m = 5, min_x = 2, max_x = 9)
```

### N = 20

-\> 1-8 with CP = 0.9551084

```{r}
sum_ngh_pmf(N = 20, M = 10, m = 5, min_x = 1, max_x = 8)
sum_ngh_pmf(N = 20, M = 10, m = 5, min_x = 2, max_x = 9)
```

### N = 21

-\> 1-9 with CP = 0.9667183

```{r}
sum_ngh_pmf(N = 21, M = 10, m = 5, min_x = 1, max_x = 8)
sum_ngh_pmf(N = 21, M = 10, m = 5, min_x = 2, max_x = 9)
sum_ngh_pmf(N = 21, M = 10, m = 5, min_x = 3, max_x = 10)

sum_ngh_pmf(N = 21, M = 10, m = 5, min_x = 1, max_x = 9)
sum_ngh_pmf(N = 21, M = 10, m = 5, min_x = 2, max_x = 10)
sum_ngh_pmf(N = 21, M = 10, m = 5, min_x = 3, max_x = 11)
```

### N = 22

-\> 1-10 with CP = 0.9749507

-\> 2-11 with CP = 0.9538418

```{r}
sum_ngh_pmf(N = 22, M = 10, m = 5, min_x = 1, max_x = 9)
sum_ngh_pmf(N = 22, M = 10, m = 5, min_x = 2, max_x = 10)
sum_ngh_pmf(N = 22, M = 10, m = 5, min_x = 3, max_x = 11)

sum_ngh_pmf(N = 22, M = 10, m = 5, min_x = 1, max_x = 10)
sum_ngh_pmf(N = 22, M = 10, m = 5, min_x = 2, max_x = 11)
sum_ngh_pmf(N = 22, M = 10, m = 5, min_x = 3, max_x = 12)
```

### N = 23

-\> 1-10 with CP = 0.9558303

-\> 2-11 with CP = 0.9538418

```{r}
sum_ngh_pmf(N = 23, M = 10, m = 5, min_x = 1, max_x = 10)
sum_ngh_pmf(N = 23, M = 10, m = 5, min_x = 2, max_x = 11)
sum_ngh_pmf(N = 23, M = 10, m = 5, min_x = 3, max_x = 12)
```

### N = 24

-\> 1-11 with CP = 0.9657424

-\> 2-12 with CP = 0.9633867

```{r}
sum_ngh_pmf(N = 24, M = 10, m = 5, min_x = 1, max_x = 10)
sum_ngh_pmf(N = 24, M = 10, m = 5, min_x = 2, max_x = 11)
sum_ngh_pmf(N = 24, M = 10, m = 5, min_x = 3, max_x = 12)

sum_ngh_pmf(N = 24, M = 10, m = 5, min_x = 1, max_x = 11)
sum_ngh_pmf(N = 24, M = 10, m = 5, min_x = 2, max_x = 12)
sum_ngh_pmf(N = 24, M = 10, m = 5, min_x = 3, max_x = 13)
```

### N = 25

-\> 2-12 with CP = 0.9553776

```{r}
sum_ngh_pmf(N = 25, M = 10, m = 5, min_x = 1, max_x = 11)
sum_ngh_pmf(N = 25, M = 10, m = 5, min_x = 2, max_x = 12)
sum_ngh_pmf(N = 25, M = 10, m = 5, min_x = 3, max_x = 13)
```

### N = 26

-\> 2-13 with CP = 0.9641868

```{r}
sum_ngh_pmf(N = 26, M = 10, m = 5, min_x = 2, max_x = 12)
sum_ngh_pmf(N = 26, M = 10, m = 5, min_x = 3, max_x = 13)

sum_ngh_pmf(N = 26, M = 10, m = 5, min_x = 2, max_x = 13)
sum_ngh_pmf(N = 26, M = 10, m = 5, min_x = 3, max_x = 14)
```

### N = 27

-\> 2-13 with CP = 0.9507022

```{r}
sum_ngh_pmf(N = 27, M = 10, m = 5, min_x = 2, max_x = 13)
sum_ngh_pmf(N = 27, M = 10, m = 5, min_x = 3, max_x = 14)
```

### N = 28

-\> 2-14 with CP = 0.9598155

-\> 3-15 with CP = 0.9530962

```{r}
sum_ngh_pmf(N = 28, M = 10, m = 5, min_x = 2, max_x = 13)
sum_ngh_pmf(N = 28, M = 10, m = 5, min_x = 3, max_x = 14)
sum_ngh_pmf(N = 28, M = 10, m = 5, min_x = 4, max_x = 15)

sum_ngh_pmf(N = 28, M = 10, m = 5, min_x = 2, max_x = 14)
sum_ngh_pmf(N = 28, M = 10, m = 5, min_x = 3, max_x = 15)
sum_ngh_pmf(N = 28, M = 10, m = 5, min_x = 4, max_x = 16)
```

### N = 29

-\> 2-15 with CP = 0.9670245

-\> 3-16 with CP = 0.9608493

```{r}
sum_ngh_pmf(N = 29, M = 10, m = 5, min_x = 2, max_x = 14)
sum_ngh_pmf(N = 29, M = 10, m = 5, min_x = 3, max_x = 15)
sum_ngh_pmf(N = 29, M = 10, m = 5, min_x = 4, max_x = 16)

sum_ngh_pmf(N = 29, M = 10, m = 5, min_x = 2, max_x = 15)
sum_ngh_pmf(N = 29, M = 10, m = 5, min_x = 3, max_x = 16)
sum_ngh_pmf(N = 29, M = 10, m = 5, min_x = 4, max_x = 17)
```

### N = 30

-\> 2-15 with CP = 0.9524496

-\> 3-16 with CP = 0.9559689

```{r}
sum_ngh_pmf(N = 30, M = 10, m = 5, min_x = 2, max_x = 15)
sum_ngh_pmf(N = 30, M = 10, m = 5, min_x = 3, max_x = 16)
sum_ngh_pmf(N = 30, M = 10, m = 5, min_x = 4, max_x = 17)
```

### N = 31

-\> 2-16 with CP = 0.9603731

-\> 3-17 with CP = 0.9630009

```{r}
sum_ngh_pmf(N = 31, M = 10, m = 5, min_x = 2, max_x = 15)
sum_ngh_pmf(N = 31, M = 10, m = 5, min_x = 3, max_x = 16)
sum_ngh_pmf(N = 31, M = 10, m = 5, min_x = 4, max_x = 17)

sum_ngh_pmf(N = 31, M = 10, m = 5, min_x = 2, max_x = 16)
sum_ngh_pmf(N = 31, M = 10, m = 5, min_x = 3, max_x = 17)
sum_ngh_pmf(N = 31, M = 10, m = 5, min_x = 4, max_x = 18)
```

### N = 32

-\> 3-17 with CP = 0.954456

```{r}
sum_ngh_pmf(N = 32, M = 10, m = 5, min_x = 2, max_x = 16)
sum_ngh_pmf(N = 32, M = 10, m = 5, min_x = 3, max_x = 17)
sum_ngh_pmf(N = 32, M = 10, m = 5, min_x = 4, max_x = 18)
```

### N = 33

-\> 3-18 with CP = 0.9614058

-\> 4-19 with CP = 0.9533698

```{r}
sum_ngh_pmf(N = 33, M = 10, m = 5, min_x = 3, max_x = 17)
sum_ngh_pmf(N = 33, M = 10, m = 5, min_x = 4, max_x = 18)

sum_ngh_pmf(N = 33, M = 10, m = 5, min_x = 3, max_x = 18)
sum_ngh_pmf(N = 33, M = 10, m = 5, min_x = 4, max_x = 19)
sum_ngh_pmf(N = 33, M = 10, m = 5, min_x = 5, max_x = 20)
```

### N = 34

-\> 3-18 with CP = 0.9501284

```{r}
sum_ngh_pmf(N = 34, M = 10, m = 5, min_x = 3, max_x = 18)
sum_ngh_pmf(N = 34, M = 10, m = 5, min_x = 4, max_x = 19)
sum_ngh_pmf(N = 34, M = 10, m = 5, min_x = 5, max_x = 20)
```

### N = 35

-\> 3-19 with CP = 0.9573237

-\> 4-20 with CP = 0.9565186

```{r}
sum_ngh_pmf(N = 35, M = 10, m = 5, min_x = 3, max_x = 18)
sum_ngh_pmf(N = 35, M = 10, m = 5, min_x = 4, max_x = 19)
sum_ngh_pmf(N = 35, M = 10, m = 5, min_x = 5, max_x = 20)

sum_ngh_pmf(N = 35, M = 10, m = 5, min_x = 3, max_x = 19)
sum_ngh_pmf(N = 35, M = 10, m = 5, min_x = 4, max_x = 20)
sum_ngh_pmf(N = 35, M = 10, m = 5, min_x = 5, max_x = 21)
```

### N = 36

-\> 3-20 with CP = 0.9633421

-\> 4-21 with CP = 0.9623507

```{r}
sum_ngh_pmf(N = 36, M = 10, m = 5, min_x = 3, max_x = 19)
sum_ngh_pmf(N = 36, M = 10, m = 5, min_x = 4, max_x = 20)
sum_ngh_pmf(N = 36, M = 10, m = 5, min_x = 5, max_x = 21)

sum_ngh_pmf(N = 36, M = 10, m = 5, min_x = 3, max_x = 20)
sum_ngh_pmf(N = 36, M = 10, m = 5, min_x = 4, max_x = 21)
sum_ngh_pmf(N = 36, M = 10, m = 5, min_x = 5, max_x = 22)
```

### N = 37

-\> 3-20 with CP = 0.9516183

-\> 4-21 with CP = 0.956464

```{r}
sum_ngh_pmf(N = 37, M = 10, m = 5, min_x = 3, max_x = 20)
sum_ngh_pmf(N = 37, M = 10, m = 5, min_x = 4, max_x = 21)
sum_ngh_pmf(N = 37, M = 10, m = 5, min_x = 5, max_x = 22)
```

### N = 38

-\> 3-21 with CP = 0.9580471

-\> 4-22 with CP = 0.9621069

-\> 5-23 with CP = 0.9538776

```{r}
sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 3, max_x = 20)
sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 4, max_x = 21)
sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 5, max_x = 22)

sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 3, max_x = 21)
sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 4, max_x = 22)
sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 5, max_x = 23)
sum_ngh_pmf(N = 38, M = 10, m = 5, min_x = 6, max_x = 24)
```

### N = 39

-\> 4-22 with CP = 0.9541562

-\> 5-23 with CP = 0.9512189

```{r}
sum_ngh_pmf(N = 39, M = 10, m = 5, min_x = 3, max_x = 21)
sum_ngh_pmf(N = 39, M = 10, m = 5, min_x = 4, max_x = 22)
sum_ngh_pmf(N = 39, M = 10, m = 5, min_x = 5, max_x = 23)
sum_ngh_pmf(N = 39, M = 10, m = 5, min_x = 6, max_x = 24)
```

### N = 40

-\> 4-23 with CP = 0.9598531

-\> 5-24 with CP = 0.9569813

```{r}
sum_ngh_pmf(N = 40, M = 10, m = 5, min_x = 4, max_x = 22)
sum_ngh_pmf(N = 40, M = 10, m = 5, min_x = 5, max_x = 23)
sum_ngh_pmf(N = 40, M = 10, m = 5, min_x = 6, max_x = 24)

sum_ngh_pmf(N = 40, M = 10, m = 5, min_x = 4, max_x = 23)
sum_ngh_pmf(N = 40, M = 10, m = 5, min_x = 5, max_x = 24)
sum_ngh_pmf(N = 40, M = 10, m = 5, min_x = 6, max_x = 25)
```

## All Acceptance Curves (Function)

```{r}
all_ac_N_unknown <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Output data frame
  results = data.frame(N = integer(), 
                       a = integer(), 
                       b = integer(), 
                       cardinality = integer(), 
                       coverage_prob = numeric())
  
  # The largest possible b
  max_x = max_N - M
  
  for (N in M:max_N) {
    
    # Temporary results for this N
    temp_results = data.frame(N = integer(), 
                              a = integer(), 
                              b = integer(), 
                              cardinality = integer(), 
                              coverage_prob = numeric())
    
    for (a in 0:max_x) {

      for (b in 0:max_x) {

        coverage_prob <- sum_ngh_pmf(N, M, m, a, b)
        cardinality   <- b - a + 1
        
        # Store in temp_results (for final filtering)
        temp_results <- rbind(temp_results, 
                              data.frame(N = N,
                                         a = a, 
                                         b = b, 
                                         cardinality = cardinality, 
                                         coverage_prob = coverage_prob))
        
      } # end b loop
    } # end a loop
    
    # Filter out sets with coverage >= conf_level, 
    # coverage in [0,1]
    temp_results <- temp_results %>%
      dplyr::filter(
        coverage_prob >= conf_level,
        coverage_prob <= 1,
        coverage_prob >= 0,
        a <= b
      ) 

    
    # If valid rows remain, update tracking
    if (nrow(temp_results) > 0) {
      
      # Append to the final results
      results <- rbind(results, temp_results)
    }
  } # end N loop
  
  # Add a "x_set" column
  filtered_results <- results %>%
    dplyr::mutate(x_set = paste(a, b, sep = "-"))
  
  return(filtered_results)
}
```

```{r}
all_ac_N_unknown_vec <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # 1) Construct a data frame of all (N, a, b) combinations:
  #    - N in [M, max_N]
  #    - a in [0, max_x]
  #    - b in [0, max_x]
  #    where max_x = max_N - M
  max_x <- max_N - M
  
  # Build the full grid
  grid_df <- expand.grid(
    N = seq.int(M, max_N),
    a = seq.int(0, max_x),
    b = seq.int(0, max_x)
  )
  
  # 2) Compute coverage_prob and cardinality in a vectorized/semi-vectorized manner:
  #    coverage_prob = sum_ngh_pmf(N, M, m, a, b)
  #    cardinality   = b - a + 1
  # If sum_ngh_pmf is NOT natively vectorized, we can use mapply:
  coverage_vec <- mapply(
    FUN = function(Ni, ai, bi) {
      sum_ngh_pmf(Ni, M, m, ai, bi)
    },
    grid_df$N,
    grid_df$a,
    grid_df$b
  )
  
  # Compute the cardinalities
  cardinality_vec <- grid_df$b - grid_df$a + 1
  
  # 3) Bind these columns to the grid
  grid_df <- cbind(
    grid_df,
    cardinality   = cardinality_vec,
    coverage_prob = coverage_vec
  )
  
  # 4) Filter rows where coverage_prob >= conf_level, coverage_prob <= 1, coverage_prob >= 0
  #    (same as your original logic).
  filtered_df <- grid_df %>%
    filter(
      coverage_prob >= conf_level,
      coverage_prob <= 1,
      coverage_prob >= 0,
      a <= b
    )
  
  # 5) Create the x_set column "a-b"
  filtered_df <- filtered_df %>%
    mutate(x_set = paste(a, b, sep = "-"))
  
  # 6) Return the filtered results
  return(filtered_df)
}
```

## All Minimal Cardinality Acceptance Curves (Function)

```{r}
all_mc_ac_N_unknown <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Output data frame
  results = data.frame(N = integer(), 
                       a = integer(), 
                       b = integer(), 
                       cardinality = integer(), 
                       coverage_prob = numeric())
  
  # The largest possible b
  max_x = max_N - M
  
  # Start a,b at (0,0)
  min_a = 0
  min_b = 0
  
  # Track the minimal cardinality found so far, if any
  prev_cardinality = 0
  
  for (N in M:max_N) {
    cat("N: ", N, "\n")
    
    # Temporary results for this N
    temp_results = data.frame(N = integer(), 
                              a = integer(), 
                              b = integer(), 
                              cardinality = integer(), 
                              coverage_prob = numeric())
    
    # Flags for the "stop once coverage dips below conf_level"
    found_min_card_for_thisN <- FALSE
    min_card_for_thisN       <- NA
    
    done_a <- FALSE
    
    for (a in min_a:max_x) {
      if (done_a) break
      
      done_b <- FALSE
      
      for (b in max(a, min_b):max_x) {
        if (done_b) break
        
        coverage_prob <- sum_ngh_pmf(N, M, m, a, b)
        cardinality   <- b - a + 1
        
        cat("a: ", a, ", b: ", b,
            ", card: ", cardinality,
            ", coverage: ", coverage_prob, "\n")
        
        # 1) If coverage >= conf_level and we haven't found the minimal-card yet,
        #    record that we've just found the minimal cardinality for this N.
        if (!found_min_card_for_thisN && coverage_prob >= conf_level) {
          found_min_card_for_thisN <- TRUE
          min_card_for_thisN       <- cardinality
          
          cat(">> Found minimal cardinality for this N =",
              min_card_for_thisN,
              "with coverage =", coverage_prob, "\n")
        }
        
        # 2) If we've already found the minimal-card for this N,
        #    and this row has that same cardinality,
        #    but coverage dips below conf_level, we break.
        else if (found_min_card_for_thisN &&
                 cardinality == min_card_for_thisN &&
                 coverage_prob < conf_level) {

          cat(">> BREAK condition triggered.",
              "Same cardinality =", min_card_for_thisN,
              "but coverage dipped below", conf_level,
              "(", coverage_prob, ")\n")
          
          done_b <- TRUE
          done_a <- TRUE
          break
        }
        
        # Store in temp_results (for final filtering)
        temp_results <- rbind(temp_results, 
                              data.frame(N = N,
                                         a = a, 
                                         b = b, 
                                         cardinality = cardinality, 
                                         coverage_prob = coverage_prob))
        
      } # end b loop
    } # end a loop
    
    # Filter out sets with coverage >= conf_level, 
    # coverage in [0,1], 
    # cardinality >= prev_cardinality,
    # and then pick minimal cardinality sets
    temp_results <- temp_results %>%
      dplyr::filter(
        coverage_prob >= conf_level,
        coverage_prob <= 1,
        coverage_prob >= 0,
        cardinality >= prev_cardinality
      ) %>%
      dplyr::group_by(N) %>%
      dplyr::slice_min(order_by = cardinality, with_ties = TRUE) %>%
      dplyr::ungroup()
    # temp_results <- temp_results %>%
    #   dplyr::filter(
    #     coverage_prob >= conf_level,
    #     coverage_prob <= 1,
    #     coverage_prob >= 0,
    #     cardinality >= prev_cardinality,
    #     cardinality == min_card_for_thisN
    #   ) 
    
    # If valid rows remain, update tracking
    if (nrow(temp_results) > 0) {
      # Keep a and b non-decreasing across N
      min_a = min(min_a, min(temp_results$a))
      min_b = min(min_b, min(temp_results$b))
      
      # The largest cardinality among these minimal-card sets
      prev_cardinality = max(temp_results$cardinality)
      
      # Append to the final results
      results <- rbind(results, temp_results)
    }
  } # end N loop
  
  # Add a "x_set" column
  filtered_results <- results %>%
    dplyr::mutate(x_set = paste(a, b, sep = "-"))
  
  return(filtered_results)
}
```

```{r}
all_mc_ac_N_unknown_vec <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Output data frame
  results <- data.frame(
    N              = integer(), 
    a              = integer(), 
    b              = integer(), 
    cardinality    = integer(), 
    coverage_prob  = numeric()
  )
  
  # The largest possible b
  max_x <- max_N - M
  
  # Start a,b at (0,0)
  min_a <- 0
  min_b <- 0
  
  # Track the minimal cardinality found so far
  prev_cardinality <- 0
  
  # Loop over N
  for (N_val in seq.int(M, max_N)) {
    # We'll store rows for the current N in a list
    temp_list <- list()
    list_idx  <- 1
    
    found_min_card_for_thisN <- FALSE
    min_card_for_thisN       <- NA
    
    done_a <- FALSE
    
    # Build all (a, b) pairs, but preserve the ascending (a, b) order 
    # to match your original nested loops exactly.
    ab_grid <- expand.grid(
      a = seq.int(min_a, max_x),
      b = seq.int(min_b, max_x)
    ) %>%
      filter(b >= a) %>%
      arrange(a, b)
    
    # We'll do a single for-loop over rows in sorted order, 
    # but replicate the break logic from the original nested loops.
    i <- 1
    while (i <= nrow(ab_grid) && !done_a) {
      a_val <- ab_grid$a[i]
      b_val <- ab_grid$b[i]
      
      # If we jumped to a new 'a' but have already 'done_a', break
      # We replicate the logic that if done_b was triggered, we also break out of the 'a' loop.
      # We detect if we've advanced beyond the initial 'a_val'.
      # Because the original code resets 'b' each time 'a' increments,
      # we need to check whether 'b' < a => if so, we keep going.
      
      coverage_prob <- sum_ngh_pmf(N_val, M, m, a_val, b_val)
      cardinality   <- b_val - a_val + 1
      
      # 1) If coverage >= conf_level and we haven't found the minimal-card yet,
      #    record that we've found the minimal cardinality for this N.
      if (!found_min_card_for_thisN && coverage_prob >= conf_level) {
        found_min_card_for_thisN <- TRUE
        min_card_for_thisN       <- cardinality
      }
      # 2) If we've already found the minimal-card for this N and this row
      #    has that same cardinality, but coverage dips below conf_level, we break.
      else if (found_min_card_for_thisN &&
               cardinality == min_card_for_thisN &&
               coverage_prob < conf_level) {
        # Trigger the break out of the 'b' loop and 'a' loop
        done_a <- TRUE
      }
      
      # Accumulate this row into our temp_list
      temp_list[[list_idx]] <- data.frame(
        N             = N_val,
        a             = a_val, 
        b             = b_val, 
        cardinality   = cardinality, 
        coverage_prob = coverage_prob
      )
      list_idx <- list_idx + 1
      
      i <- i + 1
    }
    
    # Combine all rows for this N
    if (list_idx > 1) {
      temp_results <- do.call(rbind, temp_list)
    } else {
      # No rows? then skip
      temp_results <- data.frame(
        N             = integer(), 
        a             = integer(), 
        b             = integer(), 
        cardinality   = integer(), 
        coverage_prob = numeric()
      )
    }
    
    # Filter out sets with coverage >= conf_level, coverage in [0,1],
    # cardinality >= prev_cardinality, then pick minimal cardinality sets.
    temp_results <- temp_results %>%
      dplyr::filter(
        coverage_prob >= conf_level,
        coverage_prob <= 1,
        coverage_prob >= 0,
        cardinality >= prev_cardinality
      ) %>%
      dplyr::group_by(N) %>%
      dplyr::slice_min(order_by = cardinality, with_ties = TRUE) %>%
      dplyr::ungroup()

    
    # If valid rows remain, update tracking
    if (nrow(temp_results) > 0) {
      min_a <- max(min_a, min(temp_results$a))
      min_b <- max(min_b, min(temp_results$b))
      
      # The largest cardinality among these minimal-card sets
      prev_cardinality <- max(temp_results$cardinality)
      
      # Append to the final results
      results <- rbind(results, temp_results)
    }
  }
  
  # Add a "x_set" column
  filtered_results <- results %>%
    dplyr::mutate(x_set = paste(a, b, sep = "-"))
  
  return(filtered_results)
}
```

### Plot of All Possible Minimal Cardinality Acceptance Curves

```{r}
all_ac_mc_M_10_m_5 = all_mc_ac_N_unknown(M = 10, m = 5, conf_level = 0.95, max_N = 40)
all_ac_mc_M_10_m_5
```

```{r}
conf_level= 0.95

ggplot(all_ac_mc_M_10_m_5, aes(x = N, 
                               y = coverage_prob, 
                               group = x_set, 
                               color = x_set)) +
  geom_line() +
  geom_point() +
  labs(x = "N", y = "Coverage Probability of N") +
  geom_hline(yintercept = conf_level, color = "red") +
  ylim(conf_level - 0.005, 1) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
plot_all_ac_N_unknown <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Initializing the data frame that the function will output 
  results = data.frame(N = integer(), 
                       a = integer(), 
                       b = integer(), 
                       cardinality = integer(), 
                       coverage_prob = numeric())
  
  # Setting the initial min_a and min_b, always starts with 0-0
  min_a = 0
  min_b = 0
  max_x = max_N - M
  
  for (N in M:max_N) {
    # Initializing a data frame that temporarily stores results
    temp_results = data.frame(N = integer(), 
                              a = integer(), 
                              b = integer(), 
                              cardinality = integer(), 
                              coverage_prob = numeric())
    
    # Loops through the a first, making sure it only starts at min_a so that a is 
    # non-decreasing, stops at a max_x
    for (a in min_a:max_x) {
      # Loops through b: starting at the max of a and min_b to make sure that b >= a and 
      # so that b is non-decreasing, stops at max_x
      for (b in max(a, min_b):max_x) {
        # Calculates coverage probability, cardinality, and stores it in data frame
        coverage_prob = sum_ngh_pmf(N, M, m, a, b)
        cardinality = b - a + 1
        temp_results = rbind(temp_results, data.frame(N = N, 
                                                      a = a, 
                                                      b = b, 
                                                      cardinality = cardinality, 
                                                      coverage_prob = coverage_prob))
      }
    }

    # Filter out the sets with the smallest cardinality and coverage probability >= conf_level 
    # temp_results = temp_results %>%
    #   filter(coverage_prob >= conf_level) %>%
    #   group_by(N) %>%
    #   slice_min(order_by = cardinality, with_ties = TRUE) %>%
    #   ungroup()
    
    temp_results = temp_results %>%
      filter(coverage_prob >= 0 & coverage_prob <= 1)
    
    # Updates min_a and min_b for each iteration 
    if (nrow(temp_results) > 0) {
      min_a = max(min_a, min(temp_results$a))
      min_b = max(min_b, min(temp_results$b))
      
      # Store the results from this iteration
      results <- rbind(results, temp_results)
    }
  }

  # Adds a column of the x set
  filtered_results = results %>%
    mutate(x_set = paste(a, b, sep = "-"))
  
  return(filtered_results)
}
```

```{r}
# Plot of All (non-decreasing) Acceptance Curves
plot = plot_all_ac_N_unknown(M = 10, m = 5, conf_level = 0.95, max_N = 40)
conf_level= 0.95

ggplot(plot, aes(x = N, 
                 y = coverage_prob, 
                 group = x_set, 
                 color = x_set)) +
  geom_line() +
  geom_point() +
  labs(x = "N", y = "Coverage Probability of N") +
  geom_hline(yintercept = conf_level, color = "red") +
  ylim(conf_level - 0.005, 1) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
# Plot of All Minimal Cardinality Acceptance Curves (with trends shown)
filtered_plot <- plot %>%
  filter(x_set %in% all_ac_mc_M_10_m_5$x_set)

conf_level= 0.95

ggplot() +
  geom_line(data = filtered_plot, aes(x = N, 
                                       y = coverage_prob, 
                                       group = x_set, 
                                       color = x_set)) +
  geom_point(data = all_ac_mc_M_10_m_5, aes(x = N, 
                                            y = coverage_prob, 
                                            group = x_set, 
                                            color = x_set)) +
  labs(x = "N", y = "Coverage Probability of N") +
  geom_hline(yintercept = conf_level, color = "red") +
  coord_cartesian(ylim = c(conf_level - 0.005, 1)) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
# Plot of All Minimal Cardinality Acceptance Curves (with trends shown for +1 / -1)
# USE THIS PLOT

# Initialize an empty data frame to store results
filtered_plot2 <- data.frame()

# Loop through each row in all_ac_mc_M_10_m_5
for (i in 1:nrow(all_ac_mc_M_10_m_5)) {
  # Get the current N and x_set
  current_N <- all_ac_mc_M_10_m_5$N[i]
  current_x_set <- all_ac_mc_M_10_m_5$x_set[i]
  
  # Filter for N, N-1, and N+1 where the x_set matches
  filtered_rows <- plot %>%
    filter(N %in% c(current_N, current_N - 1, current_N + 1) & x_set == current_x_set)
  
  # Append the filtered rows to the final dataframe
  filtered_plot2 <- bind_rows(filtered_plot2, filtered_rows)
}

# Remove any duplicate rows just in case
filtered_plot2 <- distinct(filtered_plot2)

conf_level = 0.95

ggplot() +
  geom_line(data = filtered_plot2, aes(x = N, 
                                       y = coverage_prob, 
                                       group = x_set, 
                                       color = x_set)) +
  geom_point(data = all_ac_mc_M_10_m_5, aes(x = N, 
                                            y = coverage_prob, 
                                            group = x_set, 
                                            color = x_set)) +
  labs(x = "N", y = "Coverage Probability") +
  geom_hline(yintercept = conf_level, color = "red") +
  coord_cartesian(ylim = c(conf_level - 0.005, 1)) +
  scale_y_continuous(breaks = c(0.95, 1)) +
  #scale_color_viridis_d(option = "D") + 
  theme_minimal() +
  theme(
    legend.position = "none", 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    axis.ticks = element_line(size = 0.5),
    axis.ticks.length = unit(2, "mm"),
    axis.text.x = element_text(margin = margin(t = 5)),
    axis.text.y = element_text(margin = margin(r = 5)))
```

```{r}
custom_colors <- c(
  "#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666", 
  "#0173b2", "#de8f05", "#029e73", "#d55e00", "#cc78bc", "#ca9161", "#fbafe4", "#949494", 
  "#56b4e9", "#f0e442", "#0072b2", "#f4a582", "#8da0cb", "#fc8d62", "#66c2a5", "#e78ac3", 
  "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3", "#c51b7d", "#8c510a", "#01665e", "#542788"
)

ggplot() +
  geom_line(data = filtered_plot2, aes(x = N, 
                                       y = coverage_prob, 
                                       group = x_set, 
                                       color = x_set)) +
  geom_point(data = all_ac_mc_M_10_m_5, aes(x = N, 
                                            y = coverage_prob, 
                                            group = x_set, 
                                            color = x_set)) +
  labs(x = "N", y = "Coverage Probability") +
  geom_hline(yintercept = conf_level, color = "red") +
  coord_cartesian(ylim = c(conf_level - 0.005, 1)) +
  scale_y_continuous(breaks = c(0.95, 1)) +
  scale_color_manual(values = custom_colors) + 
  theme_minimal() +
  theme(
    legend.position = "none", 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    axis.ticks = element_line(size = 0.5),
    axis.ticks.length = unit(2, "mm"),
    axis.text.x = element_text(margin = margin(t = 5)),
    axis.text.y = element_text(margin = margin(r = 5)))
```

## MST Acceptance Curves (Function)

```{r}
mst_ac_N_unknown <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Gets all minimal cardinality acceptance curves 
  results = all_ac_N_unknown_vec(M, m, conf_level, max_N)
  
  # Initializes data frame that will be outputted 
  final_results = data.frame(N = integer(), 
                             a = integer(), 
                             b = integer(), 
                             cardinality = integer(), 
                             coverage_prob = numeric(), 
                             x_set = character())
  
  # Initializes min_a and min_b, starting at 0-0
  min_a = 0
  min_b = 0
  previous_cardinality = 0
  
  # Loops through with each N 
  for (current_N in M:max_N) {
    # Only looks at acceptance curves for the current N
    subset_results = results %>% 
      filter(N == current_N)
    
    print(subset_results)
    # print(min(subset_results$cardinality))
    
    chosen_row <- subset_results %>%
      filter(cardinality >= previous_cardinality) %>%
      filter(a >= min_a, b >= min_b) %>% 
      filter(cardinality == min(cardinality)) %>%  
      arrange(desc(coverage_prob), desc(a), desc(b)) %>% 
      slice(1)
    
    # Updates min_a and min_b and then adds row to final outputted data frame 
    min_a = chosen_row$a
    min_b = chosen_row$b
    previous_cardinality = chosen_row$cardinality
    final_results = rbind(final_results, chosen_row)
  }
  
  final_results = final_results %>%
    arrange(N)
  
  return(final_results)
}
```

```{r}
all_ac_N_unknown_vec(M = 25, m = 15, conf_level = 0.95, max_N = 50) %>%
  filter(N == 39) 

  # filter(cardinality >= 9) %>%
  # filter(a >= 17, b >= 25) %>%
  # filter(cardinality == min(cardinality)) %>%
  # arrange(desc(coverage_prob), desc(a), desc(b))
```

```{r}
test <- mst_ac_N_unknown(M = 25, m = 15, conf_level = 0.95, max_N = 50)
test
```

```{r}
mst_ac_N_unknown(M = 10, m = 5, conf_level = 0.95, max_N = 40)
```

## CG Acceptance Curves (Function)

```{r}
cg_ac_N_unknown <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Gets all minimal cardinality acceptance curves 
  results = all_ac_N_unknown_vec(M, m, conf_level, max_N)
  
  # Initializes data frame that will be outputted 
  final_results = data.frame(N = integer(), 
                             a = integer(), 
                             b = integer(), 
                             cardinality = integer(), 
                             coverage_prob = numeric(), 
                             x_set = character())
  
  # Initializes min_a and min_b, starting at 0-0
  min_a = 0
  min_b = 0
  previous_cardinality = 0
  
  # Loops through with each N 
  for (current_N in M:max_N) {
    # Only looks at acceptance curves for the current N
    subset_results = results %>% 
      filter(N == current_N)
    
    # print(subset_results)
    # print(min(subset_results$cardinality))
    
    chosen_row <- subset_results %>%
      filter(cardinality >= previous_cardinality) %>%
      filter(a >= min_a, b >= min_b) %>% 
      filter(cardinality == min(cardinality)) %>%  
      arrange(a, b) %>%
      slice(1)
    
    # Updates min_a and min_b and then adds row to final outputted data frame 
    min_a = chosen_row$a
    min_b = chosen_row$b
    previous_cardinality = chosen_row$cardinality
    final_results = rbind(final_results, chosen_row)
  }
  
  final_results = final_results %>%
    arrange(N)
  
  return(final_results)
}
```

```{r}
cg <- cg_ac_N_unknown(M = 25, m = 15, conf_level = 0.95, max_N = 50)
```

## BK Acceptance Curves (Function)

```{r}
bk_ac_N_unknown <- function(M, m, conf_level = 0.95, max_N = 1000) {
  # Gets all minimal cardinality acceptance curves 
  results = all_ac_N_unknown_vec(M, m, conf_level, max_N)
  
  # Initializes data frame that will be outputted 
  final_results = data.frame(N = integer(), 
                             a = integer(), 
                             b = integer(), 
                             cardinality = integer(), 
                             coverage_prob = numeric(), 
                             x_set = character())
  
  # Initializes min_a and min_b, starting at 0-0
  min_a = 0
  min_b = 0
  previous_cardinality = 0
  
  # Loops through with each N 
  for (current_N in M:max_N) {
    # Only looks at acceptance curves for the current N
    subset_results = results %>% 
      filter(N == current_N)
    
    # print(subset_results)
    # print(min(subset_results$cardinality))
    
    chosen_row <- subset_results %>%
      filter(cardinality >= previous_cardinality) %>%
      filter(a >= min_a, b >= min_b) %>% 
      filter(cardinality == min(cardinality)) %>%  
      arrange(desc(a), desc(b)) %>% 
      slice(1)
    
    # Updates min_a and min_b and then adds row to final outputted data frame 
    min_a = chosen_row$a
    min_b = chosen_row$b
    previous_cardinality = chosen_row$cardinality
    final_results = rbind(final_results, chosen_row)
  }
  
  final_results = final_results %>%
    arrange(N)
  
  return(final_results)
}
```

```{r}
bk_ac_N_unknown(M = 25, m = 15, conf_level = 0.95, max_N = 50)

bk_ac_N_unknown_vec(M = 25, m = 15, conf_level = 0.95, max_N = 50)
```

## Confidence Intervals Bounds (Function)

```{r}
minimal_cardinality_ci_N_unkown <- function(M, m, conf_level = 0.95, max_N = 1000, 
                                            procedure = "MST") {
  # Chooses which minimal cardinality procedure 
  if (procedure == "MST") {
    results = mst_ac_N_unknown(M, m, conf_level, max_N)
  } 
  else if (procedure == "CG") {
    results = cg_ac_N_unknown(M, m, conf_level, max_N)
  } 
  else if (procedure == "BK") {
    results = bk_ac_N_unknown(M, m, conf_level, max_N)
  } 
  else {
    stop("Invalid procedure. Choose from 'MST', 'CG', or 'BK'.")
  }
  
  # Initializes data frame that will be outputted 
  ci_results = data.frame(x = integer(), 
                          ci_lb = integer(), 
                          ci_ub = integer(), 
                          ci = character(),
                          stringsAsFactors = FALSE)
  
  # Find the second-highest "a"
  unique_a_values <- sort(unique(results$a), decreasing = TRUE)
  if (length(unique_a_values) > 1) {
    max_x <- unique_a_values[2]  # Second-highest value
  } else {
    max_x <- unique_a_values[1]  # Fallback if only one value exists
  }
  
  # Loops through each x 
  for (x in 0:max_x) {
    # Finds first interval where x appears 
    first_occurrence = results %>% 
      filter(a <= x, x <= b) %>% 
      slice(1)
    
    # Finds last interval where x appears 
    last_occurrence = results %>% 
      filter(a <= x, x <= b) %>% 
      slice(n())
    
    # Finds the N of the corresponding above intervals and saves those as the CI bounds
    if (nrow(first_occurrence) > 0 && nrow(last_occurrence) > 0) {
      ci_lb = first_occurrence$N
      ci_ub = last_occurrence$N
      ci = paste0("[", ci_lb, ", ", ci_ub, "]")
      
      ci_results = rbind(ci_results, data.frame(x = x, 
                                                ci_lb = ci_lb, 
                                                ci_ub = ci_ub, 
                                                ci = ci))
    }
  }
  
  return(ci_results)
}
```

```{r}
minimal_cardinality_ci_N_unkown_vec <- function(M, m, conf_level = 0.95, max_N = 1000, 
                                                procedure = "MST") {
  # Choose the procedure
  if (procedure == "MST") {
    results <- mst_ac_N_unknown_vec(M, m, conf_level, max_N)
  } else if (procedure == "CG") {
    results <- cg_ac_N_unknown_vec(M, m, conf_level, max_N)
  } else if (procedure == "BK") {
    results <- bk_ac_N_unknown_vec(M, m, conf_level, max_N)
  } else {
    stop("Invalid procedure. Choose from 'MST', 'CG', or 'BK'.")
  }
  
  # Determine max_x from the second-highest 'a'
  unique_a_values <- sort(unique(results$a), decreasing = TRUE)
  max_x <- if (length(unique_a_values) > 1) unique_a_values[2] else unique_a_values[1]
  
  x_values <- seq.int(0, max_x)
  row_list <- vector("list", length(x_values))
  
  for (i in seq_along(x_values)) {
    x_val <- x_values[i]
    
    first_occurrence <- results %>% filter(a <= x_val, x_val <= b) %>% slice(1)
    last_occurrence  <- results %>% filter(a <= x_val, x_val <= b) %>% slice(n())
    
    if (nrow(first_occurrence) > 0 && nrow(last_occurrence) > 0) {
      ci_lb <- first_occurrence$N
      ci_ub <- last_occurrence$N
      ci_str <- paste0("[", ci_lb, ", ", ci_ub, "]")
      
      row_list[[i]] <- data.frame(
        x = x_val,
        ci_lb = ci_lb,
        ci_ub = ci_ub,
        ci = ci_str,
        stringsAsFactors = FALSE
      )
    }
  }
  
  ci_results <- do.call(rbind, row_list[!sapply(row_list, is.null)])
  return(ci_results)
}
```

```{r}
# Takes about 30 seconds to run
minimal_cardinality_ci_N_unkown(M = 10, m = 5, conf_level = 0.95, max_N = 60, 
                                procedure = "MST")
```

```{r}
minimal_cardinality_ci_N_unkown_vec(M = 25, m = 5, conf_level = 0.95, max_N = 100, 
                                procedure = "MST")
```

```{r}
# Takes about 30 seconds to run
minimal_cardinality_ci_N_unkown(M = 10, m = 5, conf_level = 0.95, max_N = 60, 
                                procedure = "CG")
```

```{r}
minimal_cardinality_ci_N_unkown_vec(M = 10, m = 5, conf_level = 0.95, max_N = 60, 
                                procedure = "CG")
```

```{r}
# Takes about 30 seconds to run
minimal_cardinality_ci_N_unkown(M = 10, m = 5, conf_level = 0.95, max_N = 60, 
                                procedure = "BK")
```

```{r}
minimal_cardinality_ci_N_unkown_vec(M = 10, m = 5, conf_level = 0.95, max_N = 60, 
                                procedure = "BK")
```

## Coverage Probability Plots

### MST

```{r}
# cov_prob_mst = mst_ac_N_unknown(M = 10, m = 5, conf_level = 0.95, max_N = 250)
# write.csv(cov_prob_mst, file.path("/Users/rachelroggenkemper/Documents/NegativeHypergeometric/N_Unknown", "cov_prob_mst.csv"), row.names = FALSE)

cov_prob_mst = read_csv("cov_prob_mst.csv")

conf_level= 0.95

ggplot(cov_prob_mst, aes(x = N, y = coverage_prob, group = x_set, color = x_set)) +
  geom_line() +
  geom_point() +
  labs(x = "N", y = "Coverage Probability of N") +
  geom_hline(yintercept = conf_level, color = "red") +
  ylim(conf_level - 0.005, 1) +
  theme_minimal() +
  theme(legend.position = "none")
```

### CG

```{r}
# cov_prob_cg = cg_ac_N_unknown(M = 10, m = 5, conf_level = 0.95, max_N = 250)
# write.csv(cov_prob_cg, file.path("/Users/rachelroggenkemper/Documents/NegativeHypergeometric/N_Unknown", "cov_prob_cg.csv"), row.names = FALSE)

cov_prob_cg = read_csv("cov_prob_cg.csv")

conf_level= 0.95

ggplot(cov_prob_cg, aes(x = N, y = coverage_prob, group = x_set, color = x_set)) +
  geom_line() +
  geom_point() +
  labs(x = "N", y = "Coverage Probability of N") +
  geom_hline(yintercept = conf_level, color = "red") +
  ylim(conf_level - 0.005, 1) +
  theme_minimal() +
  theme(legend.position = "none")
```

### BK

```{r}
# cov_prob_bk = bk_ac_N_unknown(M = 10, m = 5, conf_level = 0.95, max_N = 250)
# write.csv(cov_prob_bk, file.path("/Users/rachelroggenkemper/Documents/NegativeHypergeometric/N_Unknown", "cov_prob_bk.csv"), row.names = FALSE)

cov_prob_bk = read_csv("cov_prob_bk.csv")

conf_level= 0.95

ggplot(cov_prob_bk, aes(x = N, y = coverage_prob, group = x_set, color = x_set)) +
  geom_line() +
  geom_point() +
  labs(x = "N", y = "Coverage Probability of N") +
  geom_hline(yintercept = conf_level, color = "red") +
  ylim(conf_level - 0.005, 1) +
  theme_minimal() +
  theme(legend.position = "none")
```
